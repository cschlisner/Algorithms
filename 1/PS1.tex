\documentclass[12pt]{article}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\parindent}{0in}
\setlength{\parskip}{\baselineskip}

\usepackage{amsmath,amsfonts,amssymb,hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=green,
    filecolor=magenta,      
    urlcolor=blue,
}

\newcommand\lhop{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily L'H}}}{=}}}
\newcommand\contradict{\Rightarrow\!\Leftarrow}
\newcommand\lmni{\lim_{n\to\infty}}

\begin{document}
CSCI 3104 Spring 2014 \hfill Problem Set 1\\
Cole Schlisner 01/24 

\hrulefill

\begin{enumerate}

	\item	\textit{(10 pts total) For each of the following claims, determine whether they are true or false. Justify your determination (show your work). If the claim is false, state the correct asymptotic relationship as O, $\Theta$, or $\Omega$.}

	\begin{enumerate}

		\item \textit{$n + 1 = O(n^4)$}
		
		% 1A
		\begin{align}
		 n + 1 = O(n^4) & \Leftrightarrow \lmni \frac{n + 1}{n^4} = 0 \\
		 \lmni \frac{n + 1}{n^4} & \lhop \lmni \frac{1}{4n^3} \\
		 & = 0 \\
		 \therefore n + 1 = O(n^4)
		\end{align}
		%
		
		\item \textit{$2^{2n} = O(2^n)$}
		
		% 1B
		\begin{align}
		 2^{2n} = O(2^n) & \Leftrightarrow \lmni \frac{2^{2n}}{2^n} = 0 \\
		 \lmni \frac{2^{2n}}{2^n} & = \lmni \frac{2^n2^n}{2^n} \\
		 & = \lmni 2^n \\
		 & = \infty \\
		 \therefore 2^{2n} & \neq O(2^n) \\
		 (8) \implies 2^{2n} & = \Omega(2^n)
		\end{align}
		%
		\pagebreak

		\item \textit{$2^n = \Theta(2^{n+7})$}
		
		% 1C
		\begin{align}
		 2^n = \Theta(2^{n+7}) & \Leftrightarrow \lmni \frac{2^n}{2^{n+7}} = C \\
		 \lmni \frac{2^n}{2^{n+7}} & = \lmni \frac{2^n}{2^n2^7} \\
		 & = \lmni \frac{1}{2^7} \\
		 & = \frac{1}{128} = C\\
		 \therefore 2^n & = \Theta(2^{n+7}) 
		\end{align}
		%
		
		\item \textit{$1 = O(\frac{1}{n})$}
		
		% 1D
		\begin{align}
		 1 = O(\frac{1}{n}) & \Leftrightarrow \lmni \frac{1}{(\frac{1}{n})} = 0 \\
		 \lmni \frac{1}{(\frac{1}{n})} & = \lmni n \\
		 & = \infty \\
		 \therefore 1 & \neq O(\frac{1}{n}) \\
		 (19) \implies 1 & = \Omega(\frac{1}{n})
		\end{align}
		%

		\pagebreak

		\item \textit{$ln^2(n) = \Theta(lg^2(n))$}
		
		% 1E
		\begin{align}
		 ln^2(n) = \Theta(lg^2(n)) & \Leftrightarrow \lmni \frac{ln^2(n)}{lg^2(n)} = C \\
		 \lmni \frac{ln^2(n)}{lg^2(n)} & \lhop \lmni \frac{(\frac{2ln(n)}{n})}{(\frac{2ln(n)}{nln^2(2)})} \\
		 & = \lmni \frac{ln^2(2)ln(n)2n}{ln(n)2n} \\
		 & = \lmni ln^2(2) \\
		 & = ln^2(2) = C\\
		 \therefore ln^2(n) & = \Theta(lg^2(n))
		\end{align}
		%

		\item \textit{$n^2 + 2n - 4 = \Theta(n^2)$}
		
		% 1F
		\begin{align}
		 n^2 + 2n - 4 = \Omega(n^2) & \Leftrightarrow \lmni \frac{n^2 + 2n - 4}{n^2} = \infty \\
		 \lmni \frac{n^2 + 2n - 4}{n^2} & \lhop \lmni \frac{2n + 2}{2n} \\
		 & = \lmni \frac{n+1}{n} \\
		 & = \lmni 1 + \frac{1}{n} \\
		 & = 1\\
		 \therefore n^2 + 2n - 4 & \neq \Omega(n^2) \\
		 (31) \implies n^2 + 2n - 4 & = \Theta(n^2)
		\end{align}
		%

		\pagebreak

		\item \textit{$3^{3n} = \Theta(9^n)$}
		
		% 1G
		\begin{align}
		 3^{3n} = \Theta(9^n) & \Leftrightarrow \lmni \frac{3^{3n}}{9^n} = C \\
		 \lmni \frac{3^{3n}}{9^n} & = \lmni \frac{3^33^n}{9^n} \\
		 & = \lmni 9\frac{3^n}{9^n} \\
		 & = \lmni 9\frac{1}{3^n} \\
		 & = 0\\
		 \therefore 3^{3n} & \neq \Theta(9^n) \\
		 (38) \implies 3^{3n} & = O(9^n)
		\end{align}
		%

		\item \textit{$2^{n+1} = \Theta(2^{nlg(n)})$}
		
		% 1H
		\begin{align}
		 2^{n+1} = \Theta(2^{nlg(n)}) & \Leftrightarrow \lmni \frac{2^{n+1}}{2^{nlg(n)}} = C \\
		 \lmni \frac{2^{n+1}}{2^{nlg(n)}} & = \lmni \frac{2^n2}{{2^{lg(n)}}^n} \\
		 & = \lmni 2\frac{2^n}{n^n} \\
		 & = 0\\
		 \therefore 2^{n+1} & \neq \Theta(2^{nlg(n)}) \\
		 (44) \implies 2^{n+1} & = O(2^{nlg(n)})
		\end{align}
		%

		\pagebreak

		\item \textit{$\sqrt{n} = O(lg(n))$}
		
		% 1I
		\begin{align}
		 \sqrt{n} = O(lg(n)) & \Leftrightarrow \lmni \frac{\sqrt{n}}{lg(n)} = 0 \\
		 \lmni \frac{\sqrt{n}}{lg(n)} & \lhop \lmni \frac{(\frac{1}{2\sqrt{n}})}{(\frac{1}{nln(2)})} \\
		 & = \lmni \frac{nln(2)}{2\sqrt{n}} \\
		 & = \frac{ln(2)}{2} \lmni \frac{n}{\sqrt{n}} \\
		 & = \frac{ln(2)}{2} \lmni \sqrt{n} \\
		 & = \infty \\
		 \therefore \sqrt{n} & \neq O(lg(n)) \\
		 (52) \implies \sqrt{n} & = \Omega(lg(n)) 
		\end{align}
		%


		\item \textit{$10^{100} = \Theta(1)$}
		
		% 1J
		\begin{align}
		 10^{100} = \Theta(1) & \Leftrightarrow \lmni \frac{10^{100}}{1} = C \\
		 \lmni \frac{10^{100}}{1} & = 10^{100} = C \\
		 \therefore 10^{100} & = \Theta(1)
		\end{align}
		%
	
	\end{enumerate}

	\newpage
	
	\item	\textit{(15 pts) Professor Dumbledore needs your help optimizing the Hogwarts budget. You’ll
be given an array A of exchange rates for muggle money and wizard coins, expressed
at integers. Your task is help Dumbledore maximize the payoff by buying at some time
i and selling at a future time j > i, such that both A[j] > A[i] and the corresponding
difference of A[j] − A[i] is as large as possible.
For example, let A = [8, 9, 3, 4, 14, 12, 15, 19, 7, 8, 12, 11]. If we buy stock at time i = 2
with A[i] = 3 and sell at time j = 7 with A[j] = 19, Hogwarts gets in income of
19 - 3 = 16 coins.}

	\begin{enumerate}

		\item \textit{What is the running time complexity of the [given pseudocode]? Write your answer
as a Θ bound in terms of n.}


		The procedure exhausts both loops without breaking $\implies$ it makes (n-1) comparisons for the first value, (n-2) comparisons for the second, etc... for a total of $$\sum_{i=1}^{n-1} i = \frac{n(n-1+1)}{2} = \frac{n^2}{2}$$ comparisons. Additionally, each comparison takes $\Theta(1)$ time. Therefore the whole operation takes $\Theta(n^2)$ time.



		\item \textit{Explain (1 - 2 sentences) under what conditions on the contents of A the makeWizardMoney
algorithm will return 0 coins.}

		
		Either: 
		\begin{itemize}
			\item There is only 1 element in array A, in which case no comparisons can be made (in fact the second loop will never be entered). The initial value (0) of maxCoinsSoFar will be returned.
			\item A is in strictly non-increasing order. The value of \textit{coins} will always be less than 0, in which case the initial value (0) of maxCoinsSoFar will be returned.
		\end{itemize}


		\item \textit{Dumbledore knows you know that makeWizardMoney is wildly inefficient. With a wink, he suggests writing a function to make a new array M of size n such that:
				$$B[i] = \min_{0 \leq j \leq i} A[j] .$$
				That is, M[i] gives the minimum value in the subarray of A[0..i]. What is the running time complexity of the pseudocode to create the array M? Write your answer as a Θ bound in terms of n.}

		
		No more than n comparisons are needed for this operation (as it boils down to comparing A[i] to M[i-1]) $\implies$ the complexity of this algorithm is $\Theta(n)$


		\item \textit{Use the array M computed from (2c) to compute the maximum coin return in time Θ(n).}

		\begin{verbatim}
		maxReturn = 0
		for i in [1 .. A.length]
			if (A[i] - M[i]) > maxReturn
				maxReturn = A[i]-M[i]
		return maxReturn
		\end{verbatim}


		\item \textit{Use the array M computed from (2c) to compute the maximum coin return in time Θ(n).}

		\begin{verbatim}
		maxRet = 0
		for i in [1 .. A.length]
		    if (A[i] - M[i]) > maxRet
		        maxRet = A[i]-M[i]
		return maxRet
		\end{verbatim}


		\item \textit{Give Dumbledore what he wants: rewrite the original algorithm in a way that combines parts (2b)-(2d) to avoid creating a new array M.}

		\begin{verbatim}
		min = A[1]
		maxRet = 0
		for i in [1 .. A.length]
		    if (A[i] < min)
		        min = A[i]
		    elseif (A[i] - min) > maxRet
		        maxRet = (A[i] - min)
		return maxRet
		\end{verbatim}

	\end{enumerate}

	\newpage

	\item \textit{(15 pts) Consider the problem of linear search. The input is a sequence of n numbers A = ha1, a2, . . . , ani and a target value v. The output is an index i such that v = A[i] or the special value NIL if v does not appear in A.}

	\begin{enumerate}

		\item \textit{Write pseudocode for a simple linear search algorithm, which will scan through the input sequence A, looking for v.}

		\begin{verbatim}
		for i in [1 .. A.length]
		    if (A[i] = v)
		        return i
		return NIL
		\end{verbatim}

		\item \textit{Using a loop invariant, prove that your algorithm is correct. Be sure that your loop invariant and proof covers the initialization, maintenance, and termination conditions.} 


		\textbf{Loop invariant:} A[i] = v $\vee$ v $\notin$ A[1 .. i-1]


		\textbf{Initialization:} before the loop begins, $i = 1$. If A[1] = v, then both parts of the loop invariant hold. If A[1] $\neq$ v, then the loop invariant holds as $i - 1 = 0$ and the subset A[1 .. 0] is the empty set, which cannot contain v by definition. 

		\textbf{Maintenance:} during each loop, we check if A[i] = v. In such case, the loop invariant holds and the function returns i. If A[i] $\neq$ v, we increment i for the next iteration and the second half of the loop invariant holds - A[1 .. i-1] does not contain v (i-1 now being the index of the value we last checked). 

		\textbf{Termination:} when the loop exits, etiher: 
			\begin{itemize}
				\item an integer value was returned - in which case A[i] = v, satisfying the loop invariant 

				\item the loop condition was not met, indicating i = A.length + 1, meaning v was not equal to any value in A[1 .. i-1] = A. This satisfies the loop invariant and consequently NIL will (correctly) be returned.  
			\end{itemize}

	\end{enumerate}

	\newpage 

	\item \textit{ (15 pts) Crabbe and Goyle are arguing about binary search. Goyle writes the following pseudocode on the board, which he claims implements a binary search for a target value v within input array A containing n elements.}

	\begin{enumerate}

		\item \textit{Help Crabbe determine whether this code performs a correct binary search. If it does, prove to Goyle that the algorithm is correct. If it is not, state the bug(s), give line(s) of code that are correct, and then prove to Goyle that your fixed algorithm is correct.}


		\textbf{Bugs:}

		The line: \textit{binarySearch(A, 1, n-1, v)} 
		should be: \textit{binarySearch(A, 1, n, v)} 

		The line: \textit{if l $<$= r} 
		should be: \textit{if r $<$= l} 

		\textbf{Loop invariant:} $r - l > 0 \vee v \notin A[l .. r]$ 

		\textbf{Initialization:} \\When the program enters binarySearch(): $r - l = n - 1 \geq 0$

		\textbf{Maintenance:} \\If $r - l \leq 0 \implies$ return -1 $\implies v \notin$ A[l .. r] as A[l .. r] is the empty set. The invariant holds.\\
		If v $\in$ A[l .. r], $r - l > 0 \implies$ the invariant holds, return index of v \\
		These two exit points are where the 'loop' actually ends.  \\
		The quantity r-l is then decreased by 1 and the function returns the value of a call to itself with the updated parameters. 

		\textbf{Termination:}\\ If -1 was returned, $v \notin$ (A[l .. r] = the empty set) $\implies$ the invariant holds \\ 
		If an integer i was returned, v $\in$ A[l .. r] $\implies r - l > 0 \implies$ the invariant holds.


		\item \textit{ Goyle tells Crabbe that binary search is efficient because, at worst, it divides the remaining problem size in half at each step. In response Crabbe claims that four-nary search, which would divide the remaining array A into fourths at each step, would be way more efficient. Explain who is correct and why.} 

		Goyle is correct. Four-nary search would need to check twice as many values/boundaries, even though it would be cutting the problem size in half. 


	\end{enumerate} 

	\newpage

	\item \textit{(10 pts extra credit) You are given two arrays of integers A and B, both of which are sorted in ascending order. Consider the following algorithm for checking whether or not A and B have an element in common.}


	\begin{enumerate}

		\item \textit{If arrays A and B have size n, what is the worst case running time of the procedure findCommonElement? Provide a Θ bound.} 

		In the worst case, the arrays do not have an element in common, and both loops are exhausted. This means $n^2$ comparisons are made $\implies$ the procedure has a running time of $\Theta(n^2)$.

		\item \textit{For n = 5, describe input arrays $A_1$, $B_1$ that will be the best case, and arrays $A_2$, $B_2$ that will be the worst case for findCommonElement.} 

		\textbf{$A_1$} = [0,1,2,3,4] \\
		\textbf{$B_1$} = [0,1,2,3,4] 
		\medskip

		\textbf{$A_2$} = [0,1,2,3,4] \\
		\textbf{$B_2$} = [5,6,7,8,9] 


		\item \textit{Write pseudocode for an algorithm that runs in Θ(n) time for solving the problem. Your algorithm should use the fact that A and B are sorted arrays. (Hint: repurpose the merge procedure from MergeSort.)} 

		\begin{verbatim}
		findCommonElement(A, B):
		    ai = bi = 0
		    while (bi < len(B) and ai < len(A)):
		        if (A[ai]==B[bi]):
		        return True
		        if (A[ai] < B[bi]):
		            ai += 1
		        elif (B[bi] < A[ai]):
		            bi += 1
		    return False
		\end{verbatim}


	\end{enumerate}

\end{enumerate}

\newpage

\textbf{References Used}

\hrulefill

\begin{enumerate}
	\item CLRS
	\item \url{https://en.wikipedia.org/wiki/Merge_sort}
\end{enumerate}

\end{document}

